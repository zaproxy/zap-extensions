ascanbeta.HTTPParamPoll.desc = Gli attacchi di tipo Inquinamento del Parametro HTTP (HPP) sono costituiti da delimitatori di stringa di query codificate iniettare in altri parametri esistenti. Se un'applicazione web non disinfetta correttamente l'input dell'utente, un utente malintenzionato pu\u00f2 compromettere la logica dell'applicazione per eseguire attacchi sia lato client sia lato server. Una conseguenza degli attacchi HPP \u00e8 che l'attaccante pu\u00f2 potenzialmente sovrascrivere parametri HTTP hardcoded per modificare il comportamento di un'applicazione, bypassare i checkpoint di convalida dell'input e accedere e potenzialmente abusare le variabili che potessero essere fuori dalla portata diretta.
ascanbeta.HTTPParamPoll.extrainfo = https\://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution
ascanbeta.HTTPParamPoll.name = Inquinamento del parametro HTTP
ascanbeta.HTTPParamPoll.sol = Disinfettare correttamente l'input dell'utente per delimitatori di parametro

ascanbeta.backupfiledisclosure.desc = Una copia di backup del file \u00e8 stata divulgata dal server web
ascanbeta.backupfiledisclosure.name = Divulgazione di File di backup
ascanbeta.backupfiledisclosure.otherinfo = A backup of [{0}] is available at [{1}]
ascanbeta.backupfiledisclosure.refs = https\://cwe.mitre.org/data/definitions/530.html\nhttps\://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/04-Review_Old_Backup_and_Unreferenced_Files_for_Sensitive_Information.html
ascanbeta.backupfiledisclosure.soln = Non modificare i file in situ sul server web e assicurarsi che i file non necessari (compresi i file nascosti) vengano rimossi dal server web.

ascanbeta.cookieslack.affect.response.no = These cookies did NOT affect the response\: 
ascanbeta.cookieslack.affect.response.yes = These cookies affected the response\: 
ascanbeta.cookieslack.desc = Repeated GET requests\: drop a different cookie each time, followed by normal request with all cookies to stabilize session, compare responses against original baseline GET. This can reveal areas where cookie based authentication/attributes are not actually enforced.
ascanbeta.cookieslack.endline = \n
ascanbeta.cookieslack.name = Cookie Slack Detector
ascanbeta.cookieslack.otherinfo.intro = Cookies that don't have expected effects can reveal flaws in application logic. In the worst case, this can reveal where authentication via cookie token(s) is not actually enforced.\n
ascanbeta.cookieslack.separator = ,
ascanbeta.cookieslack.session.destroyed = Dropping this cookie appears to have invalidated the session\: [{0}] A follow-on request with all original cookies still had a different response than the original request. \n
ascanbeta.cookieslack.session.warning = NOTE\: Because of its name this cookie may be important, but dropping it appears to have no effect\: [{0}] \n

ascanbeta.cors.info.desc = Cross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading of resources. It relaxes the Same-Origin Policy (SOP).
ascanbeta.cors.info.name = CORS Header
ascanbeta.cors.refs = https\://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\nhttps\://portswigger.net/web-security/cors
ascanbeta.cors.soln = If a web resource contains sensitive information, the origin should be properly specified in the Access-Control-Allow-Origin header. Only trusted websites needing this resource should be specified in this header, with the most secured protocol supported.
ascanbeta.cors.vuln.desc = This CORS misconfiguration could allow an attacker to perform AJAX queries to the vulnerable website from a malicious page loaded by the victim's user agent.\nIn order to perform authenticated AJAX queries, the server must specify the header "Access-Control-Allow-Credentials\: true" and the "Access-Control-Allow-Origin" header must be set to null or the malicious page's domain. Even if this misconfiguration doesn't allow authenticated AJAX requests, unauthenticated sensitive content can still be accessed (e.g intranet websites).\nA malicious page can belong to a malicious website but also a trusted website with flaws (e.g XSS, support of HTTP without TLS allowing code injection through MITM, etc).
ascanbeta.cors.vuln.name = CORS Misconfiguration

ascanbeta.crossdomain.adobe.desc = E' possibile una contraffazione della richiesta cross-site basata su Flash/Silverlight, a causa di un errore di configurazione sul server web. 
ascanbeta.crossdomain.adobe.read.extrainfo = Il server web permette richieste con intento malevolo di lettura cross-domain provenienti da componenti Flash/Silverlight serviti da qualsiasi dominio di terze parti, a questo dominio. Se l'utente vittima ha effettuato l'accesso a questo servizio, le richieste di lettura dannose vengono elaborate utilizzando i privilegi della vittima e possono portare alla compromissione dei dati da questo servizio da parte di un sito web di terze parti non autorizzate, tramite browser della vittima. Ci\u00f2 \u00e8 probabilmente un problema se \u00e8 in uso un'implementazione di sessione basato su Cookie . 
ascanbeta.crossdomain.adobe.read.name = Configurazione errata su pi\u00f9 domini - Adobe - lettura
ascanbeta.crossdomain.adobe.read.soln = Configurare il file crossdomain.xml per limitare l'elenco dei domini che sono autorizzati a fare richieste di lettura cross-domain a questo server web utilizzando <allow-access-from domain\="example.com" >. Si dovrebbe garantire accesso a "*" (tutti i domini) se si \u00e8 certi che questo servizio non ospita nessun dato ad accesso controllato, personale o privato.
ascanbeta.crossdomain.adobe.send.extrainfo = Il server web permette di inviare dati attraverso invii dannosi cross-dominio (senza necessariamente leggere) con richieste che hanno origine da componenti Flash/Silverlight serviti da un qualsiasi dominio di terze parti, verso questo dominio. Se l'utente vittima ha avuto accesso al servizio, le richieste dannose di invio vengono processate usando i privilegi della vittima, e possono causare un attacco di tipo Cross Site Request Forgery (CSRF) , attraverso il browser della vittima. Questo \u00e8 molto probabilmente un problema se viene usata una implementazione della sessione basata sui Cookie.
ascanbeta.crossdomain.adobe.send.name = Configurazione errata su pi\u00f9 domini - Adobe - invio
ascanbeta.crossdomain.adobe.send.soln = Configurare il file crossdomain.xml per limitare l'elenco dei domini che sono autorizzati a fare richieste di invio (ma non necessariamente lettura)  cross-domain a questo server web utilizzando <allow-http-request-headers-from domain\="example.com" headers\="Authorization,X-Blahh">. Si dovrebbe garantire accesso a "*" (tutti i domini) se si \u00e8 certi che questo servizio non \u00e8 vulnerabile agli attacchi Cross Site Request Forgery (CSRF).
ascanbeta.crossdomain.name = Configurazione errata multi dominio
ascanbeta.crossdomain.refs = https\://www.adobe.com/devnet-docs/acrobatetk/tools/AppSec/CrossDomain_PolicyFile_Specification.pdf\nhttps\://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc197955(v\=vs.95)\nhttps\://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc838250(v\=vs.95)
ascanbeta.crossdomain.silverlight.desc = La falsificazione delle richieste cross-site basate su Silverlight \u00e8 possibile, dovuta ad una errata configurazione sul server web.
ascanbeta.crossdomain.silverlight.extrainfo = Il server web permette richieste con intento malevolo di lettura cross-domain provenienti da componenti Flash/Silverlight serviti da qualsiasi dominio di terze parti, a questo dominio. Se l'utente vittima ha effettuato l'accesso a questo servizio, le richieste di lettura dannose vengono elaborate utilizzando i privilegi della vittima e possono portare alla compromissione dei dati ospitati su questo servizio da parte di un sito web di terze parti non autorizzate, tramite browser della vittima. E' possibile che questo possa determinare un attacco di tipo Cross Site Request Forgery (CSRF). Ci\u00f2 \u00e8 probabilmente un problema se \u00e8 in uso un'implementazione di sessione basato su Cookie.
ascanbeta.crossdomain.silverlight.name = Configurazione errata Cross-Domain - Silverlight
ascanbeta.crossdomain.silverlight.soln = Si configuri il file clientaccesspolicy.xml in modo da restringere l'elenco dei domini che possono effettuare richieste cross-domain a questo server web, usando la direttiva <domain uri\="https\://example.com" />. Si dovrebbe garantire accesso a "*2 (tutti i domini) solo se si \u00e8 sicuri di non ospitare sul servizio nessun dato a controllo di accesso, personale o privato.

ascanbeta.csrftoken.extrainfo.annotation = Questo \u00e8 un'alert informativo in quanto il form ha una annotazione di sicurezza che indica che non \u00e8 necessario un token anti-CSRF. Ci\u00f2 dovrebbe essere testato manualmente per assicurarsi che la annotazione sia corretta.
ascanbeta.csrftoken.name = Anti-CSRF Tokens Check

ascanbeta.desc = Beta status active scan rules

ascanbeta.elinjection.desc = Il software costruisce tutto o una parte di un'istruzione di expression language (EL) in una pagina Java Server Page (JSP)utilizzando input influenzato esternamente da un componente a monte, ma non neutralizza, o lo fa in maniera incorretta, gli elementi speciali che potrebbero modificare l'istruzione EL originariamente prevista da eseguire. In alcune versioni di Spring 3.0.5 e precedenti, era presente una vulnerabilit\u00e0 (CVE-2011-2730) per la quale i tag EL sarebbero stati valutati due volte, che avrebbe veramente esposto qualsiasi applicazione all'iniezione EL. Tuttavia, anche per le versioni successive, questo problema \u00e8 ancora presente a seconda della configurazione in uso.
ascanbeta.elinjection.name = Iniezione dell'espressione in linguaggio
ascanbeta.elinjection.refs = https\://owasp.org/www-community/vulnerabilities/Expression_Language_Injection\nhttps\://cwe.mitre.org/data/definitions/917.html
ascanbeta.elinjection.soln = Assicurarsi di seguire le migliori tecniche di validazione di dati verso input non attendibile anche per assicurarsi che la codifica dell'output sia applicata quando i dati arrivano allo strato EL, affinch\u00e8 nessun metacarattere sia trovato dall'interprete all'interno del contenuto generato dall'utente prima della valutazione. I modelli pi\u00f9 ovvi da rilevare includono ${\# {, ma pu\u00f2 essere possibile codificare o frammentare questi dati.

ascanbeta.entityExpansion.desc = An exponential entity expansion, or "billion laughs" attack is a type of denial-of-service (DoS) attack. It is aimed at parsers of markup languages like XML or YAML that allow macro expansions.
ascanbeta.entityExpansion.name = Exponential Entity Expansion (Billion Laughs Attack)
ascanbeta.entityExpansion.other = The attack HTTP request received a response after {0} seconds.
ascanbeta.entityExpansion.refs = https\://en.wikipedia.org/wiki/Billion_laughs_attack\nhttps\://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\nhttps\://cwe.mitre.org/data/definitions/776.html
ascanbeta.entityExpansion.soln = Defenses against this kind of attack include capping the memory allocated in an individual parser if loss of the document is acceptable, or treating entities symbolically and expanding them lazily only when (and to the extent) their content is to be used.

ascanbeta.forbiddenBypass.desc = Bypassing 403 endpoints may be possible, the scan rule sent a payload that caused the response to be accessible (status code 200).
ascanbeta.forbiddenBypass.name = Bypassing 403
ascanbeta.forbiddenBypass.refs = https\://www.acunetix.com/blog/articles/a-fresh-look-on-reverse-proxy-related-attacks/\nhttps\://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf\nhttps\://www.contextis.com/en/blog/server-technologies-reverse-proxy-bypass

ascanbeta.httponlysite.desc = The site is only served under HTTP and not HTTPS.
ascanbeta.httponlysite.name = HTTP Only Site
ascanbeta.httponlysite.otherinfo = {0}\nZAP attempted to connect via\: {1}
ascanbeta.httponlysite.otherinfo.connectionfail = Failed to connect.
ascanbeta.httponlysite.otherinfo.differenthosts = Different Hosts.
ascanbeta.httponlysite.otherinfo.noredirection = There was no automatic redirection.
ascanbeta.httponlysite.otherinfo.nossl = Site has no SSL/TLS support.
ascanbeta.httponlysite.otherinfo.redirectionlimit = Redirection limit reached.
ascanbeta.httponlysite.otherinfo.redirecttohttp = Redirected to HTTP.
ascanbeta.httponlysite.otherinfo.urinotencoded = Redirection URI couldn't be encoded.
ascanbeta.httponlysite.refs = https\://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\nhttps\://letsencrypt.org/
ascanbeta.httponlysite.soln = Configure your web or application server to use SSL (https).

ascanbeta.httpoxy.desc = The server initiated a proxied request via the proxy specified in the HTTP Proxy header of the request.Httpoxy typically affects code running in CGI or CGI like environments.\nThis may allow attackers to\:\n* Proxy the outgoing HTTP requests made by the web application\n* Direct the server to open outgoing connections to an address and port of their choosing or\n* Tie up server resources by forcing the vulnerable software to use a malicious proxy
ascanbeta.httpoxy.name = Httpoxy - Proxy Header Misuse
ascanbeta.httpoxy.otherinfo = An outgoing message to {0} was proxied via the host and port that ZAP injected into the HTTP Proxy header.
ascanbeta.httpoxy.refs = https\://httpoxy.org/
ascanbeta.httpoxy.skipped = the Network extension is disabled
ascanbeta.httpoxy.soln = The best immediate mitigation is to block Proxy request headers as early as possible, and before they hit your application.

ascanbeta.httpsashttp.desc = Content which was initially accessed via HTTPS (i.e.\: using SSL/TLS encryption) is also accessible via HTTP (without encryption). 
ascanbeta.httpsashttp.name = HTTPS Content Available via HTTP
ascanbeta.httpsashttp.otherinfo = ZAP attempted to connect via\: {0}
ascanbeta.httpsashttp.refs = https\://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html\nhttps\://owasp.org/www-community/Security_Headers\nhttps\://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security\nhttps\://caniuse.com/stricttransportsecurity\nhttps\://datatracker.ietf.org/doc/html/rfc6797
ascanbeta.httpsashttp.soln = Ensure that your web server, application server, load balancer, etc. is configured to only serve such content via HTTPS. Consider implementing HTTP Strict Transport Security.

ascanbeta.insecurehttpmethod.connect.exploitable.desc = Il metodo HTTP insicuro [{0}] \u00e8 abilitato per questa risorsa ed \u00e8 sfruttabile. \u00c8 possibile stabilire una connessione socket in tunnel verso un servizio di terze parti, utilizzando questo metodo HTTP.  Ci\u00f2 permetterebbe al servizio di essere usato come inoltro anonimo di spam, o come proxy web, aggirando le restrizioni di rete. Esso consente inoltre di essere utilizzato per stabilire un tunnel VPN, estendendo quindi la rete perimetrale in modo da includere componenti non attendibili. 
ascanbeta.insecurehttpmethod.connect.exploitable.extrainfo = Il metodo CONNECT \u00e8 stato usato per stabilire una connessione socket a [{0}], tramite il server web.
ascanbeta.insecurehttpmethod.delete.exploitable.desc = This method is most commonly used in REST services, It is used to delete a resource.
ascanbeta.insecurehttpmethod.delete.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods, for understanding REST operations see https\://www.restapitutorial.com/lessons/httpmethods.html
ascanbeta.insecurehttpmethod.desc = Il metodo HTTP insicuro [{0}] \u00e8 attivato sul server web per questa risorsa. A seconda della configurazione del server web e dell''implementazione sottostante responsabile di servire la risorsa, questo potrebbe o meno essere sfruttabile. I metodi TRACK e TRACE possono essere utilizzati, da un utente malintenzionato, per accedere al token di autorizzazione o al cookie di sessione di un utente dell''applicazione, anche se il cookie di sessione \u00e8 protetto utilizzando il flag ''HttpOnly''. Perch\u00e8 l''attacco abbia successo, l''utente dell''applicazione deve in genere utilizzare un vecchio browser web, o un browser web che ha una vulnerabilit\u00e0 su Same Origin Policy (Politica di stessa origine, (SOP) ). Il metodo ''CONNECT'' pu\u00f2 essere utilizzato da un client web per creare un tunnel HTTP a siti Web di terze parti o servizi.
ascanbeta.insecurehttpmethod.detailed.name = Metodo HTTP insicuro - {0}
ascanbeta.insecurehttpmethod.extrainfo = Il metodo OPTIONS ha rivelato i seguenti metodi come abilitati per questa risorsa\: [{0}]
ascanbeta.insecurehttpmethod.insecure = response code {0} for insecure HTTP METHOD
ascanbeta.insecurehttpmethod.name = Metodo HTTP non sicuro
ascanbeta.insecurehttpmethod.options.exploitable.desc = This is a diagnostic method and should never be turned on in production mode.
ascanbeta.insecurehttpmethod.options.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods
ascanbeta.insecurehttpmethod.patch.exploitable.desc = This method is now most commonly used in REST services, PATCH is used for **modify** capabilities. The PATCH request only needs to contain the changes to the resource, not the complete resource.
ascanbeta.insecurehttpmethod.patch.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods, for understanding REST operations see https\://www.restapitutorial.com/lessons/httpmethods.html
ascanbeta.insecurehttpmethod.potentiallyinsecure = response code {0} for potentially insecure HTTP METHOD
ascanbeta.insecurehttpmethod.put.exploitable.desc = This method was originally intended for file management operations. It is now most commonly used in REST services, PUT is most-often utilized for **update** capabilities, PUT-ing to a known resource URI with the request body containing the newly-updated representation of the original resource..
ascanbeta.insecurehttpmethod.put.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods, for understanding REST operations see https\://www.restapitutorial.com/lessons/httpmethods.html
ascanbeta.insecurehttpmethod.soln = Disabilitare metodi insicuri come TRACK, TRACE e CONNECT sul server web e controllare che l'implementazione del servizio sottostante non supporti metodi insicuri.
ascanbeta.insecurehttpmethod.trace.exploitable.desc = Il metodo HTTP insicuro [{0}] \u00e8 abilitato per questa risorsa, ed \u00e8 sfruttabile. I metodi TRACK e TRACE possono essere utilizzati da un utente malintenzionato, per accedere ai toek di autorizzazione e ai cookie di sessione di un utente dell''applicazione, anche se il cookie di sessione \u00e8 protetto utilizzando il flag ''HttpOnly''. Perch\u00e8 l''attacco abbia successo, l''utente dell''applicazione deve in genere utilizzare un vecchio browser web, o un browser web che ha una vulnerabilit\u00e0 su Same Origin Policy (Politica di stessa origine, SOP) .
ascanbeta.insecurehttpmethod.trace.exploitable.extrainfo = Una richiesta TRACE \u00e8 stata inviata per questa richiesta, con un cookie impostato al valore [{0}]. Questo valore del cookie \u00e8 stato rilevato nella risposta HTTP, confermando la vulnerabilit\u00e0.
ascanbeta.insecurehttpmethod.webdav.exploitable.desc = This HTTP method is a WEBDAV method\: {0}. If this server is not offering any WEBDAV services, these methods should not be available.
ascanbeta.insecurehttpmethod.webdav.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods

ascanbeta.integeroverflow.desc = An integer overflow condition exists when an integer used in a compiled program extends beyond the range limits and has not been properly checked from the input stream.
ascanbeta.integeroverflow.error1 = Potenziale overflow di intero. E' cambiato il codice di stato sull'input di una lunga stringa di interi casuali.
ascanbeta.integeroverflow.error2 = Potenziale overflow di intero. E' cambiato il codice di stato sull'input di una lunga stringa di zero.
ascanbeta.integeroverflow.error3 = Potenziale overflow di intero. E' cambiato il codice di stato sull'input di una lunga stringa di uno.
ascanbeta.integeroverflow.error4 = Potenziale overflow di intero. E' cambiato il codice di stato sull'input di una lunga stringa di nove.
ascanbeta.integeroverflow.name = Errore di overflow di intero
ascanbeta.integeroverflow.refs = https\://en.wikipedia.org/wiki/Integer_overflow\nhttps\://cwe.mitre.org/data/definitions/190.html
ascanbeta.integeroverflow.soln = In order to prevent overflows and divide by 0 (zero) errors in the application, please rewrite the backend program, checking if the values of integers being processed are within the application's allowed range. This will require a recompilation of the backend executable.

ascanbeta.name = Active Scan Rules - beta

ascanbeta.noanticsrftokens.desc = Nessun Token Anti-CSRF \u00e8 stato trovato nel form HTML.
ascanbeta.noanticsrftokens.name = Assenza di Token Anti-CSRF

ascanbeta.oobxss.name = Out of Band XSS
ascanbeta.oobxss.skipped = no Active Scan OAST service is selected.

ascanbeta.proxydisclosure.attack = TRACE, OPTIONS methods with 'Max-Forwards' header. TRACK method.
ascanbeta.proxydisclosure.desc = {0} proxy server(s) were detected or fingerprinted. This information helps a potential attacker to determine \n - A list of targets for an attack against the application.\n - Potential vulnerabilities on the proxy servers that service the application.\n - The presence or absence of any proxy-based components that might cause attacks against the application to be detected, prevented, or mitigated. 
ascanbeta.proxydisclosure.extrainfo.proxyserver = - {0}
ascanbeta.proxydisclosure.extrainfo.proxyserver.header = Using the TRACE, OPTIONS, and TRACK methods, the following proxy servers have been identified between ZAP and the application/web server\: 
ascanbeta.proxydisclosure.extrainfo.silentproxyserver = - {0}
ascanbeta.proxydisclosure.extrainfo.silentproxyserver.header = The following 'silent' proxy servers were identified. Due to their behaviour, it is not known at which point in the network topology these proxy servers reside\:
ascanbeta.proxydisclosure.extrainfo.traceenabled = The 'TRACE' method is enabled on one or more of the proxy servers, or on the origin server. This method leaks all information submitted from the web browser and proxies back to the user agent. This may facilitate 'Cross Site Tracing' attacks. 
ascanbeta.proxydisclosure.extrainfo.unknown = Sconosciuto
ascanbeta.proxydisclosure.extrainfo.webserver = - {0}
ascanbeta.proxydisclosure.extrainfo.webserver.header = The following web/application server has been identified\: 
ascanbeta.proxydisclosure.name = Proxy Disclosure
ascanbeta.proxydisclosure.refs = https\://tools.ietf.org/html/rfc7231\#section-5.1.2
ascanbeta.proxydisclosure.soln = Disable the 'TRACE' method on the proxy servers, as well as the origin web/application server.\nDisable the 'OPTIONS' method on the proxy servers, as well as the origin web/application server, if it is not required for other purposes, such as 'CORS' (Cross Origin Resource Sharing).\nConfigure the web and application servers with custom error pages, to prevent 'fingerprintable' product-specific error pages being leaked to the user in the event of HTTP errors, such as 'TRACK' requests for non-existent pages.\nConfigure all proxies, application servers, and web servers to prevent disclosure of the technology and version information in the 'Server' and 'X-Powered-By' HTTP response headers.\n

ascanbeta.relativepathconfusion.desc = The web server is configured to serve responses to ambiguous URLs in a manner that is likely to lead to confusion about the correct "relative path" for the URL. Resources (CSS, images, etc.) are also specified in the page response using relative, rather than absolute URLs. In an attack, if the web browser parses the "cross-content" response in a permissive manner, or can be tricked into permissively parsing the "cross-content" response, using techniques such as framing, then the web browser may be fooled into interpreting HTML as CSS (or other content types), leading to an XSS vulnerability.
ascanbeta.relativepathconfusion.extrainfo.contenttypeenabled = A Content Type of "{0}" was specified. If the web browser is employing strict parsing rules, this will prevent cross-content attacks from succeeding. Quirks Mode in the web browser would disable strict parsing.  
ascanbeta.relativepathconfusion.extrainfo.framingallowed = No X-Frame-Options header was specified, so the page can be framed, and this can be used to enable Quirks Mode, allowing the specified Content Type to be bypassed.
ascanbeta.relativepathconfusion.extrainfo.morethanonebasetag = More than one <base> tag was specified in the HTML <head> tag to define the location for relative URLs, which is not valid.
ascanbeta.relativepathconfusion.extrainfo.nobasetag = No <base> tag was specified in the HTML <head> tag to define the location for relative URLs.
ascanbeta.relativepathconfusion.extrainfo.nocontenttype = No Content Type was specified, so Quirks Mode is not required to exploit the vulnerability in the web browser. 
ascanbeta.relativepathconfusion.extrainfo.quirksmodeenabledexplicitly = Quirks Mode is explicitly enabled via <meta http-equiv\="{0}", allowing the specified Content Type to be bypassed.
ascanbeta.relativepathconfusion.extrainfo.quirksmodeenabledimplicitly = Quirks Mode is implicitly enabled via the use of an old DOCTYPE with PUBLIC id "{0}", allowing the specified Content Type to be bypassed in some web browsers.
ascanbeta.relativepathconfusion.extrainfo.quirksmodeenabledimplicitlynodoctype = Quirks Mode is implicitly enabled via the absence of a DOCTYPE, allowing the specified Content Type to be bypassed.
ascanbeta.relativepathconfusion.name = Relative Path Confusion
ascanbeta.relativepathconfusion.refs = https\://arxiv.org/abs/1811.00917\nhttps\://hsivonen.fi/doctype/\nhttps\://www.w3schools.com/tags/tag_base.asp
ascanbeta.relativepathconfusion.soln = Web servers and frameworks should be updated to be configured to not serve responses to ambiguous URLs in such a way that the relative path of such URLs could be mis-interpreted by components on either the client side, or server side.\nWithin the application, the correct use of the "<base>" HTML tag in the HTTP response will unambiguously specify the base URL for all relative URLs in the document.\nUse the "Content-Type" HTTP response header to make it harder for the attacker to force the web browser to mis-interpret the content type of the response.\nUse the "X-Content-Type-Options\: nosniff" HTTP response header to prevent the web browser from "sniffing" the content type of the response.\nUse a modern DOCTYPE such as "<\!doctype html>" to prevent the page from being rendered in the web browser using "Quirks Mode", since this results in the content type being ignored by the web browser.\nSpecify the "X-Frame-Options" HTTP response header to prevent Quirks Mode from being enabled in the web browser using framing attacks. 

ascanbeta.sessionfixation.alert.attack = Campo {0}\: [{1}]
ascanbeta.sessionfixation.alert.cookie.extrainfo = Cookie impostato in risposta quando campo [{0}] del cookie \u00e8 impostato su NULL\: [{1}]\nCookie impostato in risposta con valore del cookie (valido) preso in prestito nella richiesta [{1}]\: [{2}]
ascanbeta.sessionfixation.alert.cookie.extrainfo.loginpage = The url on which the issue was discovered was flagged as a logon page.\n\nThis issue should be manually validated by checking that the session token set on the logon page is still valid once logged in, and that the token can be used to directly access a page/resource which should require the user to be logged in.
ascanbeta.sessionfixation.alert.url.extrainfo = Un probabile valore di sessione \u00e8 apparso negli URL nell''output HTML quando il parametro URL o pseudo parametro URL [{0}] \u00e8 impostato su NULL\: [{1}]\nQuando questa sessione [{1}]  ''in prestito'' \u00e8 usata in una successiva richiesta per questa URL, non viene creata una nuova sessione.
ascanbeta.sessionfixation.alert.url.extrainfo.loginpage = L'URL sul quale il problema \u00e8 stato scoperto \u00e8 stata contrassegnata come una pagina di accesso.
ascanbeta.sessionfixation.desc = E' possibile un problema di Session Fixation. Se questo problema si verifica con un URL di login (dove l'utente si autentica sull'applicazione), allora l'URL pu\u00f2 essere dato da un attaccante, insieme a un id di sessione immutato, ad una vittima, per poi assumere l'identit\u00e0 della vittima utilizzando l'id di sessione specificato. Se il problema si verifica con una pagina non di login, l'URL e l'id di sessione immutato possono essere utilizzati solo da un utente malintenzionato per monitorare le azioni di un utente non autenticato. Se la vulnerabilit\u00e0 si verifica su un campo di cookie o un campo di modulo (parametro POST) piuttosto che su un parametro URL (GET), allora alcune altre vulnerabilit\u00e0 possono essere richieste al fine di impostare il campo cookie sul browser della vittima, per consentire che la vulnerabilit\u00e0 sia sfruttabile.
ascanbeta.sessionfixation.name = Session Fixation
ascanbeta.sessionfixation.refs = https\://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication\nhttps\://owasp.org/www-community/attacks/Session_fixation\nhttps\://acrossecurity.com/papers/session_fixation.pdf\nhttps\://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html
ascanbeta.sessionfixation.soln = 1) Prevent the attacker from gaining a session id by enforcing strict session ids, and by only allocating session ids upon successful authentication to the application.\n2) The server should always create a new session id upon authentication, regardless of whether a session is already in place.\n3) Bind the session id to some identifiable client attribute combination, such as IP address, SSL client certificate.\n4) Sessions, when destroyed, must be destroyed on the server, as well as on the client.\n5) Implement a logout mechanism which will destroy all previous sessions for the client.\n6) Implement absolute session timeouts.\n7)Switch from a URL based to a cookie or form based session id implementation, as the latter typically require additional vulnerabilities, in order to be exploitable by an attacker\n

ascanbeta.sessionidaccessiblebyjavascript.alert.attack = Campo {0}\: [{1}]
ascanbeta.sessionidaccessiblebyjavascript.alert.extrainfo = Nel campo identificatore di sessione {0} [{1}], il valore [{2}] pu\u00f2 essere acceduto utilizzando JavaScript nel browser web
ascanbeta.sessionidaccessiblebyjavascript.alert.extrainfo.loginpage = L'URL sul quale il problema \u00e8 stato scoperto \u00e8 stata contrassegnata come una pagina di accesso.
ascanbeta.sessionidaccessiblebyjavascript.desc = Un cookie di sessione Id inviato dal server (quando l'URL viene modificato impostando a NULL il campo parametro indicato ) pu\u00f2 essere acceduto tramite JavaScript sul client. In concomitanza con un'altra vulnerabilit\u00e0, questo pu\u00f2 permettere di dirottare la sessione .  
#Session Id Cookie accessible by JavaScript
ascanbeta.sessionidaccessiblebyjavascript.name = Cookie dell'ID di Sessione accessibile a JavaScript
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidaccessiblebyjavascript.refs=
ascanbeta.sessionidaccessiblebyjavascript.soln = 1) utilizzare il flag 'httponly' quando si imposta un cookie contenente un id di sessione, per evitare che venga consultato da JavaScript nel browser web.  

ascanbeta.sessionidexpiry.alert.attack = Campo {0}\: [{1}]
ascanbeta.sessionidexpiry.alert.extrainfo = identificatore di sessione {0} campo [{1}], valore [{2}] pu\u00f2 essere acceduto fino al [{3}] (poich\u00e9 il cookie \u00e8 stato ricevuto a {4}), a meno che la sessione sia distrutta.
ascanbeta.sessionidexpiry.alert.extrainfo.loginpage = L'URL sul quale il problema \u00e8 stato scoperto \u00e8 stata contrassegnata come una pagina di accesso.
ascanbeta.sessionidexpiry.browserclose = chiudere il browser
ascanbeta.sessionidexpiry.desc = Un cookie di sessione Id inviato dal server (quando l'URL viene modificato impostando a NULL il campo parametro indicato) \u00e8 impostato per essere valido per un tempo eccessivo. Questo pu\u00f2 essere sfruttabile da un attaccante, se l'utente dimentica di effettuare il logout, se la funzionalit\u00e0 di disconnessione non distrugge correttamente la sessione, o se l'id di sessione \u00e8 compromesso da altri mezzi.     
#Session Id Cookie Expiry
ascanbeta.sessionidexpiry.name = Il valore Session ID Expiry Time/Max-Age \u00e8 eccessivo
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidexpiry.refs=
ascanbeta.sessionidexpiry.soln = 1) utilizzare le direttive di cookie 'Expire' o 'Max-Age' quando si imposta un cookie contenente un id di sessione, per impedire sia disponibile per periodi prolungati di tempo.\n2) verificare che la funzionalit\u00e0 di disconnessione esista, e che distrugga correttamente la sessione.\n3) usare altre misure preventive per assicurarsi che se un id di sessione \u00e8 compromesso, esso non possa essere sfruttato.
ascanbeta.sessionidexpiry.timeexpired = Scaduto
ascanbeta.sessionidexpiry.timelessthanonehour = Meno di un'ora
ascanbeta.sessionidexpiry.timemorethanoneday = Pi\u00f9 di un giorno
ascanbeta.sessionidexpiry.timemorethanonehour = Pi\u00f9 di un'ora
ascanbeta.sessionidexpiry.timemorethanoneweek = Pi\u00f9 di una settimana

ascanbeta.sessionidexposedinurl.alert.attack = Campo {0}\: [{1}]
ascanbeta.sessionidexposedinurl.alert.extrainfo = Il campo {0}  di [{1}] contiene un identificatore di sessione esposto [{2}]
ascanbeta.sessionidexposedinurl.alert.extrainfo.loginpage = L'URL sul quale il problema \u00e8 stato scoperto \u00e8 stata contrassegnata come una pagina di accesso.
ascanbeta.sessionidexposedinurl.desc = A session id is exposed in the URL. By sharing such a website URL (containing the session id), a naive user may be inadvertently granting access to their data, compromising its confidentiality, integrity, and availability.  URLs containing the session identifier also appear in web browser bookmarks, web server log files, and proxy server log files. 
#Exposed Session Id messages
ascanbeta.sessionidexposedinurl.name = ID sessione esposto
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidexposedinurl.refs = https\://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication
ascanbeta.sessionidexposedinurl.soln = Utilizzare un'implementazione di gestione della sessione pi\u00f9 sicura, come ad esempio una che utilizzi cookies di sessione, che non sono facilmente condivisi inavvertitamente, e che in genere non compaiono nel file di log del server o nei segnalibri del browser web.

ascanbeta.sessionidsentinsecurely.alert.attack = Campo {0}\: [{1}]
ascanbeta.sessionidsentinsecurely.alert.extrainfo = Il campo {0} identificatore di sessione [{1}], il valore [{2}] pu\u00f2 essere inviato tramite un meccanismo insicuro.  
ascanbeta.sessionidsentinsecurely.alert.extrainfo.loginpage = L'URL sul quale il problema \u00e8 stato scoperto \u00e8 stata contrassegnata come una pagina di accesso.
ascanbeta.sessionidsentinsecurely.alert.extrainfo.secureflagnotset = L'impostazione "sicuro" non \u00e8 stata impostata nel cookie di sessione fornito dal server.
ascanbeta.sessionidsentinsecurely.desc = Un id di sessione pu\u00f2 essere inviato tramite un meccanismo insicuro. Nel caso di un cookie inviato nella richiesta, ci\u00f2 si verifica quando viene usato HTTP anzich\u00e9 HTTPS.  Nel caso di un cookie inviato dal server in risposta (quando l'URL viene modificato impostando a NULL il campo parametro indicato ), il flag 'secure' non \u00e8 impostato, permettendo che il cookie sia in seguito inviato tramite HTTP invece che tramite HTTPS. Ci\u00f2 potrebbe consentire ad un intercettatore passivo lungo il percorso di rete di avere pieno accesso alla sessione della vittima.  
#Session Id Cookie not sent securely
ascanbeta.sessionidsentinsecurely.name = ID di sessione trasmesso in modo non sicuro
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidsentinsecurely.refs = https\://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication
ascanbeta.sessionidsentinsecurely.soln = 1) utilizzare l'ultima versione disponibile di SSL/TLS (per HTTPS) su tutte le pagine dove un id di sessione viene comunicato tra il browser e il server web.\n2) non consentire che la comunicazione sia degradata ad un protocollo HTTP non crittografato.\n3) utilizzare il flag 'secure' quando si imposta un cookie contenente un id di sessione, per impedire la sua trasmissione successiva con un meccanismo insicuro.\n4) Inoltrare le richieste HTTP di pagina non sicura alla pagina sicura HTTPS equivalente.  

ascanbeta.shellshock.desc = Il server sta eseguendo una versione della shell Bash che consente agli aggressori remoti di eseguire codice arbitrario 
ascanbeta.shellshock.extrainfo = Da CVE-2014-6271\: GNU Bash fino alla versione 4.3 le stringhe  finali nei processi dopo le definizioni di funzioni nei valori delle variabili d\u00b4ambiente, permette ad aggressori remoti di eseguire codice arbitrario tramite un ambiente appositamente predisposto, come dimostrato dai vettori che coinvolgono la funzionalit\u00e0 ForceCommand in OpenSSH sshd, i moduli mod_cgi e mod_cgid in Apache HTTP Server, script eseguiti da client DHCP non specificati e altre situazioni in cui l\u00b4impostazione dell\u00b4ambiente avviene attraverso un limite di privilegio dall'esecuzione di Bash , meglio conosciuto come "ShellShock." Nota\: la correzione originale di questo problema era errata; CVE-2014-7169 \u00e8 stato assegnato per coprire la vulnerabilit\u00e0 che \u00e8 ancora presente dopo la correzione errata.
ascanbeta.shellshock.name = Esecuzione di codice remoto - Shell Shock
ascanbeta.shellshock.ref = https\://nvd.nist.gov/vuln/detail/CVE-2014-6271\nhttps\://www.troyhunt.com/everything-you-need-to-know-about2/
ascanbeta.shellshock.soln = Aggiornare Bash sul server all\u00b4ultima versione
ascanbeta.shellshock.timingbased.evidence = Utilizzando l''attacco, un ritardo di [{0}] millisecondi  \u00e8 stata causato e rilevato

ascanbeta.sourcecodedisclosure.desc = The source code for the current page was disclosed by the web server.
ascanbeta.sourcecodedisclosure.gitbased.evidence = The source code for [{0}] was extracted using [{1}]
ascanbeta.sourcecodedisclosure.gitbased.name = Source Code Disclosure - Git 
ascanbeta.sourcecodedisclosure.gitbased.soln = Ensure that Git metadata files are not deployed to the web server or application server
ascanbeta.sourcecodedisclosure.lfibased.extrainfo = The output for the source code filename [{0}] differs sufficiently from that of the random parameter [{1}], at [{2}%], compared to a threshold of [{3}%]
ascanbeta.sourcecodedisclosure.lfibased.name = Source Code Disclosure - File Inclusion
ascanbeta.sourcecodedisclosure.svnbased.extrainfo = Il codice sorgente per [{0}] \u00e8 stato trovato a [{1}]
ascanbeta.sourcecodedisclosure.svnbased.name = Divulgazione di codice sorgente - SVN
ascanbeta.sourcecodedisclosure.svnbased.soln = Assicurarsi che i file di metadati di SVN non vengono distribuiti sul web server o sul server applicativo

ascanbeta.sourcecodedisclosurecve-2012-1823.desc = Alcune versioni PHP, quando configurate per essere eseguite usando CGI, non gestiscono correttamente le stringhe di query con mancanza di un carattere escape "\=", consentendo la divulgazione del codice sorgente PHP e l'esecuzione di codice arbitrario. In questo caso, il contenuto del file PHP \u00e8 stato servito direttamente al browser web. Questa uscita di solito contiene  codice PHP, anche se pu\u00f2 anche contenere direttamente HTML.
ascanbeta.sourcecodedisclosurecve-2012-1823.name = Rivelazione di codice sorgente - CVE-2012-1823
ascanbeta.sourcecodedisclosurecve-2012-1823.soln = Aggiornare all'ultima versione stabile di PHP, o utilizzare il server web Apache e il modulo mod_rewrite per filtrare le richieste dannose mediante le direttive "RewriteCond" e "RewriteRule".

ascanbeta.ssrf.desc = The web server receives a remote address and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.
ascanbeta.ssrf.name = Server Side Request Forgery
ascanbeta.ssrf.otherinfo.canaryinbody = The canary token from the out-of-band service was found in the response body.
ascanbeta.ssrf.refs = https\://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html
ascanbeta.ssrf.skipped = no Active Scan OAST service is selected.
ascanbeta.ssrf.soln = Do not accept remote addresses as request parameters, and if you must, ensure that they are validated against an allow-list of expected values.

ascanbeta.text4shell.desc = Apache Commons Text prior to 1.10.0 allows RCE when applied to untrusted input due to insecure interpolation defaults.Apache Commons Text performs variable interpolation, allowing properties to be dynamically evaluated and expanded.The application has been shown to initial contact with remote servers via variable interpolation and may well be vulnerable to Remote Code Execution (RCE).
ascanbeta.text4shell.name = Text4shell (CVE-2022-42889)
ascanbeta.text4shell.refs = https\://nvd.nist.gov/vuln/detail/CVE-2022-42889\nhttps\://securitylab.github.com/advisories/GHSL-2022-018_Apache_Commons_Text/
ascanbeta.text4shell.skipped = no Active Scan OAST service is selected.
ascanbeta.text4shell.soln = Upgrade Apache Commons Text prior to version 1.10.0 or newer.

ascanbeta.usernameenumeration.alert.attack = Modificare il campo [{0}]\: [{1}] e monitorare l''uscita 
ascanbeta.usernameenumeration.alert.extrainfo = Il parametro [{0}]  [{1}] perde  informazioni sull''esistenza o meno di un utente. Le [{5}] differenze in uscita, per il valore di username originale valido [{2}] e il valore username non valido [{3}] sono\: [{4}]
ascanbeta.usernameenumeration.desc = \u00c8 possibile enumerare gli utenti, basati su differenti risposte HTTP quando vengono forniti nomi utente validi e non validi. Questo aumenterebbe notevolmente la probabilit\u00e0 di successo di tecniche di forzatura della password su base di forza bruta contro il sistema.  Si noti che falsi positivi possono a volte essere minimizzati aumentando l'opzione 'Forza dell'attacco' in ZAP.  Si prega di controllare manualmente il campo 'Altre informazioni' per confermare se questo \u00e8 effettivamente un problema. 
ascanbeta.usernameenumeration.name = Enumerazione utenti possibile
ascanbeta.usernameenumeration.refs = https\://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/03-Identity_Management_Testing/04-Testing_for_Account_Enumeration_and_Guessable_User_Account.html\nhttps\://dl.ifip.org/db/conf/sec/sec2011/FreilingS11.pdf\nhttps\://cwe.mitre.org/data/definitions/204.html
ascanbeta.usernameenumeration.soln = Non divulgare dettagli se uno username \u00e8 valido o non valido. In particolare, per i tentativi di login fallito, non distinguere tra un utente valido e una password non valida nel messaggio di errore, titolo della pagina, contenuto della pagina, intestazioni HTTP o logica di reindirizzamento.

