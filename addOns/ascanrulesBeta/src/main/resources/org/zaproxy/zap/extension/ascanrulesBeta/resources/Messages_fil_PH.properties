ascanbeta.HTTPParamPoll.desc = Ang pag-atake ng HTTP Parameter Polusyon (HPP) ay binubuo ng pag-inject ng mga naka-encode na query string delimiter sa iba pang umiiral na mga parameter. Kung ang isang webaplikasyon ay hindi maayos na sanitize ang input ng user, ang isang nakakahamak na user ay maaaring ikompromiso ang lohika ng aplikasyon upang maisagawa ang alinman sa pag-atake ng client-side o server. Ang isang kinahinatnan ng pag-atake ng HPP ay ang pag-atake ng potensyal na pag-override ng umiiral na hard-code na mga parameter ng HTTP upang baguhin ang pag-uugali ng isang application, pag-bypass ang mga checkpoint ng pagpapatunay ng input, at pag-access at maaaring pagsamantalahan ang mga variable na maaaring direktang maabot.
ascanbeta.HTTPParamPoll.extrainfo = https\://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution
ascanbeta.HTTPParamPoll.name = Polusyon ng Parameter ng HTTP
ascanbeta.HTTPParamPoll.sol = Maayos na sanitize ang input ng user para sa mga delimiter ng parameter

ascanbeta.backupfiledisclosure.desc = Ang isang backup ng file ay isiwalat ng web server
ascanbeta.backupfiledisclosure.name = Paglilitaw ng Backup ng File
ascanbeta.backupfiledisclosure.otherinfo = A backup of [{0}] is available at [{1}]
ascanbeta.backupfiledisclosure.refs = https\://cwe.mitre.org/data/definitions/530.html\nhttps\://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/04-Review_Old_Backup_and_Unreferenced_Files_for_Sensitive_Information.html
ascanbeta.backupfiledisclosure.soln = Huwag baguhin ang mga file na in-situ sa server ng web, at tiyakin na ang mga hindi kinakailangang mga file (kabilang ang mga nakatagong file) ay aalisin mula sa web server.

ascanbeta.cookieslack.affect.response.no = These cookies did NOT affect the response\: 
ascanbeta.cookieslack.affect.response.yes = These cookies affected the response\: 
ascanbeta.cookieslack.desc = Repeated GET requests\: drop a different cookie each time, followed by normal request with all cookies to stabilize session, compare responses against original baseline GET. This can reveal areas where cookie based authentication/attributes are not actually enforced.
ascanbeta.cookieslack.endline = \n
ascanbeta.cookieslack.name = Cookie Slack Detector
ascanbeta.cookieslack.otherinfo.intro = Cookies that don't have expected effects can reveal flaws in application logic. In the worst case, this can reveal where authentication via cookie token(s) is not actually enforced.\n
ascanbeta.cookieslack.separator = ,
ascanbeta.cookieslack.session.destroyed = Dropping this cookie appears to have invalidated the session\: [{0}] A follow-on request with all original cookies still had a different response than the original request. \n
ascanbeta.cookieslack.session.warning = NOTE\: Because of its name this cookie may be important, but dropping it appears to have no effect\: [{0}] \n

ascanbeta.cors.info.desc = Cross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading of resources. It relaxes the Same-Origin Policy (SOP).
ascanbeta.cors.info.name = CORS Header
ascanbeta.cors.refs = https\://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\nhttps\://portswigger.net/web-security/cors
ascanbeta.cors.soln = If a web resource contains sensitive information, the origin should be properly specified in the Access-Control-Allow-Origin header. Only trusted websites needing this resource should be specified in this header, with the most secured protocol supported.
ascanbeta.cors.vuln.desc = This CORS misconfiguration could allow an attacker to perform AJAX queries to the vulnerable website from a malicious page loaded by the victim's user agent.\nIn order to perform authenticated AJAX queries, the server must specify the header "Access-Control-Allow-Credentials\: true" and the "Access-Control-Allow-Origin" header must be set to null or the malicious page's domain. Even if this misconfiguration doesn't allow authenticated AJAX requests, unauthenticated sensitive content can still be accessed (e.g intranet websites).\nA malicious page can belong to a malicious website but also a trusted website with flaws (e.g XSS, support of HTTP without TLS allowing code injection through MITM, etc).
ascanbeta.cors.vuln.name = CORS Misconfiguration

ascanbeta.crossdomain.adobe.desc = Maaaring posible ang posibleng pagpapasok ng kahilingan sa pamamagitan ng Flash/Silverlight sa pamamagitan ng isang misconfiguration sa web server. 
ascanbeta.crossdomain.adobe.read.extrainfo = Pinapayagan ng web server ang mga nakakahamak na data ng cross-domain na mga kahilingan sa pagbabasa mula sa mga bahagi ng Flash/Silverlight na nagsilbi mula sa anumang ikatlong partido na domain, sa domain na ito. Kung ang user ng biktima ay naka-log in sa serbisyong ito, ang mga kahina-hinalang read request ay pinoproseso gamit ang mga pribilehiyo ng biktima, at maaaring magresulta sa data mula sa serbisyong ito na nakompromiso ng isang hindi awtorisadong third party na web site, sa pamamagitan ng web browser ng biktima. Ito ay partikular na malamang na maging isang isyu kung ang pagpapatupad ng pagpapatupad ng session na Cookie ay ginagamit. 
ascanbeta.crossdomain.adobe.read.name = Pag-configure ng Cross-Domain - Adobe - Basahin
ascanbeta.crossdomain.adobe.read.soln = I-configure ang file na crossdomain.xml upang paghigpitan ang listahan ng mga domain na pinapayagang gumawa ng mga hiling sa cross-domain na basahin sa web server na ito, gamit <allow-access-from domain\="example.com">. Dapat mo lamang bigyan ng access sa "*" (all domains) kung ikaw ay tiyak na ang serbisyong ito ay hindi nagho-host ng anumang access-controlled, personalized, o pribadong data.
ascanbeta.crossdomain.adobe.send.extrainfo = Pinapayagan ng web server ang nakahahamak na data ng cross-domain na ipadala (ngunit hindi kinakailangan basahin) ang mga kahilingan na nagmula sa mga bahagi ng Flash/Silverlight na nagsilbi mula sa anumang ikatlong partido na domain, sa domain na ito. Kung ang user ng biktima ay naka-log in sa serbisyong ito, ang mga kahilingan sa pagpapadala ng mga nakakahamak ay pinoproseso gamit ang mga pribilehiyo ng biktima, at maaaring magresulta sa pag-atake ng Cross Site Request Forgery (CSRF), sa pamamagitan ng web browser ng biktima. Ito ay partikular na malamang na maging isang isyu kung ang pagpapatupad ng pagpapatupad ng session na Cookie ay ginagamit.
ascanbeta.crossdomain.adobe.send.name = Ang pag-configure ng Cross-Domain - Adobe - Ipadala
ascanbeta.crossdomain.adobe.send.soln = I-configure ang file ng crossdomain.xml upang paghigpitan ang listahan ng mga domain na pinapayagang gumawa ng cross-domain na ipadala (ngunit hindi kinakailangang magbasa) ng mga kahilingan sa web server na ito, gamit <allow-http-request-headers-from domain\="example.com" headers\="Authorization,X-Blahh">. You should only grant access to "*" (all domains) kung ikaw ay tiyak na ang serbisyong ito ay hindi maaaring mahina sa pag-atake ng Cross Site Request Forgery (CSRF).
ascanbeta.crossdomain.name = Pag-configure ng Cross-Domain
ascanbeta.crossdomain.refs = https\://www.adobe.com/devnet-docs/acrobatetk/tools/AppSec/CrossDomain_PolicyFile_Specification.pdf\nhttps\://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc197955(v\=vs.95)\nhttps\://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc838250(v\=vs.95)
ascanbeta.crossdomain.silverlight.desc = Maaaring posible ang request ng palsipikado na cross-site na palsipikado sa Silverlight, dahil sa maling pag-configure sa web server.
ascanbeta.crossdomain.silverlight.extrainfo = Pinapayagan ng web server ang mga nakakahamak na kahilingan sa cross-domain na nagmumula sa mga sangkap ng Silverlight na nagsilbi mula sa anumang ikatlong partido na domain, sa domain na ito. Kung ang user ng biktima ay naka-log in sa serbisyong ito, ang mga nakakahamak na kahilingan ay naproseso gamit ang mga pribilehiyo ng biktima, at maaaring magresulta sa data mula sa serbisyong ito na nakompromiso ng isang hindi awtorisadong web site ng third party, sa pamamagitan ng mga web browser ng biktima. Maaari rin itong magresulta sa mga pag-atake ng Cross Site Request Forgery (CSRF). Ito ay partikular na malamang na maging isang isyu kung ang pagpapatupad ng pagpapatupad ng session na Cookie ay ginagamit.
ascanbeta.crossdomain.silverlight.name = Cross-Domain Misconfiguration - Silverlight
ascanbeta.crossdomain.silverlight.soln = I-configure ang file ng clientaccesspolicy.xml upang paghigpitan ang listahan ng mga domain na pinapayagan na gumawa ng mga kahilingan sa cross-domain sa web server na ito, gamit <domain uri\="https\://example.com" />. You should only grant access to "*" (all domains) kung ikaw ay tiyak na ang serbisyong ito ay hindi nagho-host ng anumang access-controlled, personalized, o pribadong data.

ascanbeta.csrftoken.extrainfo.annotation = Ito ay isang alerto sa impormasyon na ang porma ay may isang anotasyon ng seguridad na nagpapahiwatig na hindi nito kailangan ang Token ng anti-CSRF. Ito ay dapat manu-manong sinubukan upang matiyak na ang anotasyon ay tama.
ascanbeta.csrftoken.name = Anti-CSRF Tokens Check

ascanbeta.desc = Beta status active scan rules

ascanbeta.elinjection.desc = Ang software na gumagawa ng lahat o parte ng isang expression ng wika (EL) pahayag na nasa Java Server Page (JSP) paggamit ng externally-influenced na input galing sa upstream component, pero ito ay hindi naka-nuetralize o hindi sakto ang pag-nuetralize ng special na mga elemento na posibleng makapagbago ng intended EL Language na mga tag na mag-evaluate ng dalawang beses, na epektibong naglalabas ng kahit anong aplikasyon sa EL injection. Pero, kahit na para sa lahat ng mga bersyon, itong kahinaan ay posibleng mag depende sa configuration.
ascanbeta.elinjection.name = Expression Language Injection
ascanbeta.elinjection.refs = https\://owasp.org/www-community/vulnerabilities/Expression_Language_Injection\nhttps\://cwe.mitre.org/data/definitions/917.html
ascanbeta.elinjection.soln = Gawin ang pag-validate ng data na magandang praktis laban sa hindi pinagkakatiwalaan na mga pagpasok at pasiguro na ang output encoding ay na-apply kung ay data ay darating sa EL layer, upang walang metacharacter ang mahanap sa interpreset sa loob ng user content bago ang evaluation. Ang pinaka obvious na mga pattern ay na-derect sa pagsama ${ and \#{, pero ito ay posibleng maka encode o fragment sa data na ito.

ascanbeta.entityExpansion.desc = An exponential entity expansion, or "billion laughs" attack is a type of denial-of-service (DoS) attack. It is aimed at parsers of markup languages like XML or YAML that allow macro expansions.
ascanbeta.entityExpansion.name = Exponential Entity Expansion (Billion Laughs Attack)
ascanbeta.entityExpansion.other = The attack HTTP request received a response after {0} seconds.
ascanbeta.entityExpansion.refs = https\://en.wikipedia.org/wiki/Billion_laughs_attack\nhttps\://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\nhttps\://cwe.mitre.org/data/definitions/776.html
ascanbeta.entityExpansion.soln = Defenses against this kind of attack include capping the memory allocated in an individual parser if loss of the document is acceptable, or treating entities symbolically and expanding them lazily only when (and to the extent) their content is to be used.

ascanbeta.forbiddenBypass.desc = Bypassing 403 endpoints may be possible, the scan rule sent a payload that caused the response to be accessible (status code 200).
ascanbeta.forbiddenBypass.name = Bypassing 403
ascanbeta.forbiddenBypass.refs = https\://www.acunetix.com/blog/articles/a-fresh-look-on-reverse-proxy-related-attacks/\nhttps\://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf\nhttps\://www.contextis.com/en/blog/server-technologies-reverse-proxy-bypass

ascanbeta.httponlysite.desc = The site is only served under HTTP and not HTTPS.
ascanbeta.httponlysite.name = HTTP Only Site
ascanbeta.httponlysite.otherinfo = {0}\nZAP attempted to connect via\: {1}
ascanbeta.httponlysite.otherinfo.connectionfail = Failed to connect.
ascanbeta.httponlysite.otherinfo.differenthosts = Different Hosts.
ascanbeta.httponlysite.otherinfo.noredirection = There was no automatic redirection.
ascanbeta.httponlysite.otherinfo.nossl = Site has no SSL/TLS support.
ascanbeta.httponlysite.otherinfo.redirectionlimit = Redirection limit reached.
ascanbeta.httponlysite.otherinfo.redirecttohttp = Redirected to HTTP.
ascanbeta.httponlysite.otherinfo.urinotencoded = Redirection URI couldn't be encoded.
ascanbeta.httponlysite.refs = https\://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html\nhttps\://letsencrypt.org/
ascanbeta.httponlysite.soln = Configure your web or application server to use SSL (https).

ascanbeta.httpoxy.desc = The server initiated a proxied request via the proxy specified in the HTTP Proxy header of the request.Httpoxy typically affects code running in CGI or CGI like environments.\nThis may allow attackers to\:\n* Proxy the outgoing HTTP requests made by the web application\n* Direct the server to open outgoing connections to an address and port of their choosing or\n* Tie up server resources by forcing the vulnerable software to use a malicious proxy
ascanbeta.httpoxy.name = Httpoxy - Proxy Header Misuse
ascanbeta.httpoxy.otherinfo = An outgoing message to {0} was proxied via the host and port that ZAP injected into the HTTP Proxy header.
ascanbeta.httpoxy.refs = https\://httpoxy.org/
ascanbeta.httpoxy.skipped = the Network extension is disabled
ascanbeta.httpoxy.soln = The best immediate mitigation is to block Proxy request headers as early as possible, and before they hit your application.

ascanbeta.httpsashttp.desc = Content which was initially accessed via HTTPS (i.e.\: using SSL/TLS encryption) is also accessible via HTTP (without encryption). 
ascanbeta.httpsashttp.name = HTTPS Content Available via HTTP
ascanbeta.httpsashttp.otherinfo = ZAP attempted to connect via\: {0}
ascanbeta.httpsashttp.refs = https\://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html\nhttps\://owasp.org/www-community/Security_Headers\nhttps\://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security\nhttps\://caniuse.com/stricttransportsecurity\nhttps\://datatracker.ietf.org/doc/html/rfc6797
ascanbeta.httpsashttp.soln = Ensure that your web server, application server, load balancer, etc. is configured to only serve such content via HTTPS. Consider implementing HTTP Strict Transport Security.

ascanbeta.insecurehttpmethod.connect.exploitable.desc = Ang hindi secure na paraan ng HTTP [{0}] ay pinagana para sa mapagkukunan na ito, at magagamit. Napag-alaman na posible na magtatag ng koneksyon ng tunneled socket sa isang third party service, gamit ang HTTP na paraan. Ito ay magpapahintulot sa serbisyo na magamit bilang isang hindi nakikilalang spam relay, o bilang isang proxy ng web, na nililimitahan ang mga paghihigpit sa network. Pinapayagan din nito na magamit upang maitatag ang isang tunneled VPN, epektibong pagpapalawak ng perimeter ng network upang isama ang mga hindi pinagkakatiwalaang mga bahagi. 
ascanbeta.insecurehttpmethod.connect.exploitable.extrainfo = Ang pamamaraan ng CONNECT ay ginamit upang magtatag ng koneksyon ng socket sa [{0}], sa pamamagitan ng web server.
ascanbeta.insecurehttpmethod.delete.exploitable.desc = This method is most commonly used in REST services, It is used to delete a resource.
ascanbeta.insecurehttpmethod.delete.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods, for understanding REST operations see https\://www.restapitutorial.com/lessons/httpmethods.html
ascanbeta.insecurehttpmethod.desc = Ang hindi secure na paraan ng HTTP [{0}] ay pinagana sa web server para sa mapagkukunan na ito. Depende sa pagsasaayos ng web server, at ang kalakip na pagpapatupad na may pananagutan sa paghahatid ng mapagkukunan, ito ay maaaring o hindi maaaring maisasama. Ang mga pamamaraan ng TRACK and TRACE ay maaaring gamitin ng isang magsasalakay, upang makakuha ng access sa permiso ng token / session cookie ng isang gumagamit ng application, kahit na ang session cookie ay protektado gamit ang ''HttpOnly'' na bandila. Para sa matagumpay na pag-atake, ang user ng application ay kadalasang gumagamit ng isang mas lumang web browser, o isang web browser na may baluktot na bypass na Same Origin Policy (SOP). Ang ''CONNECT'' na paraan ay maaaring gamitin ng isang web client upang lumikha ng isang HTTP tunnel sa mga website o serbisyo ng ikatlong partido.
ascanbeta.insecurehttpmethod.detailed.name = Walang Pautang HTTP na Paraan - {0}
ascanbeta.insecurehttpmethod.extrainfo = Ang pamamaraan ng mga OPTION ay nagsisiwalat sa sumusunod na mga pamamaraan ng HTTP para sa mapagkukunang ito\: [
ascanbeta.insecurehttpmethod.insecure = response code {0} for insecure HTTP METHOD
ascanbeta.insecurehttpmethod.name = Hindi secure na Paraan ng HTTP
ascanbeta.insecurehttpmethod.options.exploitable.desc = This is a diagnostic method and should never be turned on in production mode.
ascanbeta.insecurehttpmethod.options.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods
ascanbeta.insecurehttpmethod.patch.exploitable.desc = This method is now most commonly used in REST services, PATCH is used for **modify** capabilities. The PATCH request only needs to contain the changes to the resource, not the complete resource.
ascanbeta.insecurehttpmethod.patch.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods, for understanding REST operations see https\://www.restapitutorial.com/lessons/httpmethods.html
ascanbeta.insecurehttpmethod.potentiallyinsecure = response code {0} for potentially insecure HTTP METHOD
ascanbeta.insecurehttpmethod.put.exploitable.desc = This method was originally intended for file management operations. It is now most commonly used in REST services, PUT is most-often utilized for **update** capabilities, PUT-ing to a known resource URI with the request body containing the newly-updated representation of the original resource..
ascanbeta.insecurehttpmethod.put.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods, for understanding REST operations see https\://www.restapitutorial.com/lessons/httpmethods.html
ascanbeta.insecurehttpmethod.soln = Huwag paganahin ang mga pamamaraan ng hindi secure na paraan tulad ng TRACK, TRACE, at CONNECT sa web server, at tiyakin na ang pagpapatuloy ng pagpapatupad ng serbisyo ay hindi sumusuporta sa mga pamamaraan ng hindi secure.
ascanbeta.insecurehttpmethod.trace.exploitable.desc = Ang hindi secure na paraan ng HTTP [{0}] ay pinagana para sa mapagkukunan na ito, at magagamit. Ang mga pamamaraan ng TRACK and TRACE ay maaaring gamitin ng isang magsasalakay, upang makakuha ng daan at permiso ng token / session cookie ng isang gumagamit ng application, kahit na ang session cookie ay protektado gamit ang ''HttpOnly'' na bandila. Para sa matagumpay na pag-atake, ang user ng application ay kadalasang gumagamit ng isang mas lumang web browser, o isang web browser na may baluktot na bypass na Same Origin Policy (SOP).
ascanbeta.insecurehttpmethod.trace.exploitable.extrainfo = Ang isang kahilingan ng TRACE ay ipinadala para sa kahilingan na ito, na may isang custom na halaga ng cookie [{0}]. Ang halaga ng cookie na ito ay isiwalat sa tugon ng HTTP, na nagpapatunay sa kahinaan.
ascanbeta.insecurehttpmethod.webdav.exploitable.desc = This HTTP method is a WEBDAV method\: {0}. If this server is not offering any WEBDAV services, these methods should not be available.
ascanbeta.insecurehttpmethod.webdav.exploitable.extrainfo = See the discussion on stackexchange\: https\://security.stackexchange.com/questions/21413/how-to-exploit-http-methods

ascanbeta.integeroverflow.desc = An integer overflow condition exists when an integer used in a compiled program extends beyond the range limits and has not been properly checked from the input stream.
ascanbeta.integeroverflow.error1 = Potensyal na Integer Overflow. Ang kalagayan ng code ay nagbago sa input ng isang mahabang string ng mga random na integer.
ascanbeta.integeroverflow.error2 = Potensyal na Integer Overflow. Binago ang code ng katayuan sa input ng isang mahabang string ng mga zero.
ascanbeta.integeroverflow.error3 = Potensyal na Integer Overflow. Ang code ng katayuan ay nagbago sa input ng isang mahabang string ng mga bago.
ascanbeta.integeroverflow.error4 = Potensyal na Integer Overflow. Ang code ng katayuan ay nagbago sa input ng isang mahabang string ng nines.
ascanbeta.integeroverflow.name = Error sa Pag-overlay ng Integer
ascanbeta.integeroverflow.refs = https\://en.wikipedia.org/wiki/Integer_overflow\nhttps\://cwe.mitre.org/data/definitions/190.html
ascanbeta.integeroverflow.soln = In order to prevent overflows and divide by 0 (zero) errors in the application, please rewrite the backend program, checking if the values of integers being processed are within the application's allowed range. This will require a recompilation of the backend executable.

ascanbeta.name = Active Scan Rules - beta

ascanbeta.noanticsrftokens.desc = Walang nakitang mga token ng Anti-CSRF sa isang form sa pagsumite ng HTML.
ascanbeta.noanticsrftokens.name = Kawalan ng mga Tokens ng Anti-CSRF

ascanbeta.oobxss.name = Out of Band XSS
ascanbeta.oobxss.skipped = no Active Scan OAST service is selected.

ascanbeta.proxydisclosure.attack = TRACE, OPTIONS methods with 'Max-Forwards' header. TRACK method.
ascanbeta.proxydisclosure.desc = {0} proxy server(s) were detected or fingerprinted. This information helps a potential attacker to determine \n - A list of targets for an attack against the application.\n - Potential vulnerabilities on the proxy servers that service the application.\n - The presence or absence of any proxy-based components that might cause attacks against the application to be detected, prevented, or mitigated. 
ascanbeta.proxydisclosure.extrainfo.proxyserver = - {0}
ascanbeta.proxydisclosure.extrainfo.proxyserver.header = Using the TRACE, OPTIONS, and TRACK methods, the following proxy servers have been identified between ZAP and the application/web server\: 
ascanbeta.proxydisclosure.extrainfo.silentproxyserver = - {0}
ascanbeta.proxydisclosure.extrainfo.silentproxyserver.header = The following 'silent' proxy servers were identified. Due to their behaviour, it is not known at which point in the network topology these proxy servers reside\:
ascanbeta.proxydisclosure.extrainfo.traceenabled = The 'TRACE' method is enabled on one or more of the proxy servers, or on the origin server. This method leaks all information submitted from the web browser and proxies back to the user agent. This may facilitate 'Cross Site Tracing' attacks. 
ascanbeta.proxydisclosure.extrainfo.unknown = Ang hindi alam
ascanbeta.proxydisclosure.extrainfo.webserver = - {0}
ascanbeta.proxydisclosure.extrainfo.webserver.header = The following web/application server has been identified\: 
ascanbeta.proxydisclosure.name = Proxy Disclosure
ascanbeta.proxydisclosure.refs = https\://tools.ietf.org/html/rfc7231\#section-5.1.2
ascanbeta.proxydisclosure.soln = Disable the 'TRACE' method on the proxy servers, as well as the origin web/application server.\nDisable the 'OPTIONS' method on the proxy servers, as well as the origin web/application server, if it is not required for other purposes, such as 'CORS' (Cross Origin Resource Sharing).\nConfigure the web and application servers with custom error pages, to prevent 'fingerprintable' product-specific error pages being leaked to the user in the event of HTTP errors, such as 'TRACK' requests for non-existent pages.\nConfigure all proxies, application servers, and web servers to prevent disclosure of the technology and version information in the 'Server' and 'X-Powered-By' HTTP response headers.\n

ascanbeta.relativepathconfusion.desc = The web server is configured to serve responses to ambiguous URLs in a manner that is likely to lead to confusion about the correct "relative path" for the URL. Resources (CSS, images, etc.) are also specified in the page response using relative, rather than absolute URLs. In an attack, if the web browser parses the "cross-content" response in a permissive manner, or can be tricked into permissively parsing the "cross-content" response, using techniques such as framing, then the web browser may be fooled into interpreting HTML as CSS (or other content types), leading to an XSS vulnerability.
ascanbeta.relativepathconfusion.extrainfo.contenttypeenabled = A Content Type of "{0}" was specified. If the web browser is employing strict parsing rules, this will prevent cross-content attacks from succeeding. Quirks Mode in the web browser would disable strict parsing.  
ascanbeta.relativepathconfusion.extrainfo.framingallowed = No X-Frame-Options header was specified, so the page can be framed, and this can be used to enable Quirks Mode, allowing the specified Content Type to be bypassed.
ascanbeta.relativepathconfusion.extrainfo.morethanonebasetag = More than one <base> tag was specified in the HTML <head> tag to define the location for relative URLs, which is not valid.
ascanbeta.relativepathconfusion.extrainfo.nobasetag = No <base> tag was specified in the HTML <head> tag to define the location for relative URLs.
ascanbeta.relativepathconfusion.extrainfo.nocontenttype = No Content Type was specified, so Quirks Mode is not required to exploit the vulnerability in the web browser. 
ascanbeta.relativepathconfusion.extrainfo.quirksmodeenabledexplicitly = Quirks Mode is explicitly enabled via <meta http-equiv\="{0}", allowing the specified Content Type to be bypassed.
ascanbeta.relativepathconfusion.extrainfo.quirksmodeenabledimplicitly = Quirks Mode is implicitly enabled via the use of an old DOCTYPE with PUBLIC id "{0}", allowing the specified Content Type to be bypassed in some web browsers.
ascanbeta.relativepathconfusion.extrainfo.quirksmodeenabledimplicitlynodoctype = Quirks Mode is implicitly enabled via the absence of a DOCTYPE, allowing the specified Content Type to be bypassed.
ascanbeta.relativepathconfusion.name = Relative Path Confusion
ascanbeta.relativepathconfusion.refs = https\://arxiv.org/abs/1811.00917\nhttps\://hsivonen.fi/doctype/\nhttps\://www.w3schools.com/tags/tag_base.asp
ascanbeta.relativepathconfusion.soln = Web servers and frameworks should be updated to be configured to not serve responses to ambiguous URLs in such a way that the relative path of such URLs could be mis-interpreted by components on either the client side, or server side.\nWithin the application, the correct use of the "<base>" HTML tag in the HTTP response will unambiguously specify the base URL for all relative URLs in the document.\nUse the "Content-Type" HTTP response header to make it harder for the attacker to force the web browser to mis-interpret the content type of the response.\nUse the "X-Content-Type-Options\: nosniff" HTTP response header to prevent the web browser from "sniffing" the content type of the response.\nUse a modern DOCTYPE such as "<\!doctype html>" to prevent the page from being rendered in the web browser using "Quirks Mode", since this results in the content type being ignored by the web browser.\nSpecify the "X-Frame-Options" HTTP response header to prevent Quirks Mode from being enabled in the web browser using framing attacks. 

ascanbeta.sessionfixation.alert.attack = {0} patlang\: [{1}]
ascanbeta.sessionfixation.alert.cookie.extrainfo = Itakda ang cookie bilang tugon kapag ang patlang ng cookie na [{0}] ay nakatakda sa NULL\: [{1}]\nAng cookie na itinakda bilang tugon sa halaga ng cookie (valid) na cookie sa kahilingan [{1}] \: [{2}]
ascanbeta.sessionfixation.alert.cookie.extrainfo.loginpage = The url on which the issue was discovered was flagged as a logon page.\n\nThis issue should be manually validated by checking that the session token set on the logon page is still valid once logged in, and that the token can be used to directly access a page/resource which should require the user to be logged in.
ascanbeta.sessionfixation.alert.url.extrainfo = Ang isang malamang na halaga ng session ay lumitaw sa mga URL sa output ng HTML kapag ang parameter ng URL na pseudo URL [{0}] ay nakatakda sa NULL\: [{1}]\nKapag ang session na ''hiniram'' [{1}] ay ginagamit sa isang kasunod na kahilingan para sa URL na ito, ang isang bagong session ay hindi nilikha.
ascanbeta.sessionfixation.alert.url.extrainfo.loginpage = Ang url kung saan natuklasan ang isyu ay na-flag bilang isang pahina ng logon.
ascanbeta.sessionfixation.desc = Maaaring posible ang pag-aayos ng Session. Kung ang isyu na ito ay nangyayari sa isang login na URL (kung saan pinatutunayan ng user ang kanilang sarili sa application), maaaring maibigay ang URL ng isang magsasalakay, kasama ang isang fixed session id, sa isang biktima, upang ipagpalagay na mamaya ang pagkakakilanlan ng biktima gamit ang ibinigay na session id. Kung ang isyu ay nangyayari sa isang hindi naka-login na pahina, ang URL at fixed session id ay maaari lamang gamitin ng isang magsasalakay upang masubaybayan ang mga aksyon na hindi awtorisadong user. Kung ang kahinaan ay nangyayari sa isang patlang ng cookie o isang field ng form (POST parameter) sa halip na sa isang URL (GET) na parameter, pagkatapos ay ang ilang iba pang mga kahinaan ay maaaring kinakailangan din upang itakda ang patlang ng cookie sa browser ng biktima, upang payagan ang kahinaan upang mapagsamantalahan.
ascanbeta.sessionfixation.name = Pag-aayos ng Session
ascanbeta.sessionfixation.refs = https\://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication\nhttps\://owasp.org/www-community/attacks/Session_fixation\nhttps\://acrossecurity.com/papers/session_fixation.pdf\nhttps\://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html
ascanbeta.sessionfixation.soln = 1) Prevent the attacker from gaining a session id by enforcing strict session ids, and by only allocating session ids upon successful authentication to the application.\n2) The server should always create a new session id upon authentication, regardless of whether a session is already in place.\n3) Bind the session id to some identifiable client attribute combination, such as IP address, SSL client certificate.\n4) Sessions, when destroyed, must be destroyed on the server, as well as on the client.\n5) Implement a logout mechanism which will destroy all previous sessions for the client.\n6) Implement absolute session timeouts.\n7)Switch from a URL based to a cookie or form based session id implementation, as the latter typically require additional vulnerabilities, in order to be exploitable by an attacker\n

ascanbeta.sessionidaccessiblebyjavascript.alert.attack = {0} patlang\: [{1}]
ascanbeta.sessionidaccessiblebyjavascript.alert.extrainfo = sesyon identifier {0} field [{1}], halaga [{2}] ay ma-access gamit ang JavaScript sa web browser
ascanbeta.sessionidaccessiblebyjavascript.alert.extrainfo.loginpage = Ang url kung saan natuklasan ang isyu ay na-flag bilang isang pahina ng logon.
ascanbeta.sessionidaccessiblebyjavascript.desc = Ang Sesyon ID cookie na ipinadala ng server (kapag ang URL na ito ay binagong mga setting na nakapangalan sa parameter field na NULL) ito ay posibleng mapasukan ng JavaScript sa client. Kaugnay sa isa pang kahinaan, ito ay maaring payagan ng sesyon upang hijacked.  
#Session Id Cookie accessible by JavaScript
ascanbeta.sessionidaccessiblebyjavascript.name = Sesyon ID ng Cookie na magagamit sa JavaScript
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidaccessiblebyjavascript.refs=
ascanbeta.sessionidaccessiblebyjavascript.soln = 1) Gamitin ang 'httponly na flag kung ang setting sa cookie ay naglalaman ng isang sesyon id, upang maiwasan ang mga ito mula sa pagiging ma-access sa JavaScript sa web browser.  

ascanbeta.sessionidexpiry.alert.attack = {0} patlang\: [{1}]
ascanbeta.sessionidexpiry.alert.extrainfo = sesyon identifier {0} patlang [{1}], halaga [{2}] ay maaring ma-access hanggang [{3}] (mula ang cookie ay natanggap sa {4}), maliban ang sesyon ay nasira.
ascanbeta.sessionidexpiry.alert.extrainfo.loginpage = Ang url kung saan natuklasan ang isyu ay na-flag bilang isang pahina ng logon.
ascanbeta.sessionidexpiry.browserclose = i-browse ang sarado
ascanbeta.sessionidexpiry.desc = Ang Sesyon ID sa cookie na ipinadala ng server (kapag ang URL na ito ay binago sa pamamagitan ng pagtatakda ng parameter na field sa NULL) ay itinakda para maging balido para sa isang sobrang tagal na panahon. Ito ay maaring pagsasamantalahan ng attacker kung ang user ay nakakalimot mag-log out, kung ang lumabas na pag-andar ay hindi tama na sirain ang sesyon, o kung ang mga id ng sesyon ay nakompromiso sa ilang iba pang mga paraan.     
#Session Id Cookie Expiry
ascanbeta.sessionidexpiry.name = Sesyon ID na Expiry Time/Max-Age ay sumobra
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidexpiry.refs=
ascanbeta.sessionidexpiry.soln = 1) Gamitin ang 'Expire' o Max-Age' na cookie na mga directive na kung ang setting na cookie ang naglalaman na isang sesyon id, para ito ay maiwasan na pwedeng gamitin para sa pagpatagal ng punto ng oras.\n2) Pasiguro na ang mga logout na mga functionality ay umiiral, at ito ay tama ng magwawasak ng sesyon.\n3) Gamitin ang ibang mga iniiwasan na mga sukat para ito ay mapatunayan na hindi isang sesyon id ay nakumprimiso, ito ay nagdudulot ng paggamit muli.
ascanbeta.sessionidexpiry.timeexpired = Paso na
ascanbeta.sessionidexpiry.timelessthanonehour = Mas mababa sa oras
ascanbeta.sessionidexpiry.timemorethanoneday = Higit na isang araw
ascanbeta.sessionidexpiry.timemorethanonehour = Higit na isang oras
ascanbeta.sessionidexpiry.timemorethanoneweek = Higit na isang linggo

ascanbeta.sessionidexposedinurl.alert.attack = {0} patlang\: [{1}]
ascanbeta.sessionidexposedinurl.alert.extrainfo = {0} field [{1}] naglalaman ng isang nakalantad na tagatukoy ng session [{2}]
ascanbeta.sessionidexposedinurl.alert.extrainfo.loginpage = Ang url kung saan natuklasan ang isyu ay na-flag bilang isang pahina ng logon.
ascanbeta.sessionidexposedinurl.desc = A session id is exposed in the URL. By sharing such a website URL (containing the session id), a naive user may be inadvertently granting access to their data, compromising its confidentiality, integrity, and availability.  URLs containing the session identifier also appear in web browser bookmarks, web server log files, and proxy server log files. 
#Exposed Session Id messages
ascanbeta.sessionidexposedinurl.name = Exposed Session ID
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidexposedinurl.refs = https\://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication
ascanbeta.sessionidexposedinurl.soln = Gumamit ng mas ligtas na pagpapatupad ng pamamahala ng session, tulad ng isa na gumagamit ng cookies ng session, na hindi kasing madaling ibinabahagi nang hindi sinasadya, at hindi karaniwang lumilitaw sa mga file ng log ng server o mga bookmark ng web browser.

ascanbeta.sessionidsentinsecurely.alert.attack = {0} patlang\: [{1}]
ascanbeta.sessionidsentinsecurely.alert.extrainfo = sesyon na identifer {0} field [{1}], halaga [{2}] ay posibleng mapadala sa pamamagitan ng hindi secure na mekanismo.  
ascanbeta.sessionidsentinsecurely.alert.extrainfo.loginpage = Ang url kung saan natuklasan ang isyu ay na-flag bilang isang pahina ng logon.
ascanbeta.sessionidsentinsecurely.alert.extrainfo.secureflagnotset = Ang 'secure' flag ay hindi nai-set sa sesyon na cookie na ibinigay ng server.
ascanbeta.sessionidsentinsecurely.desc = Ang sesyon id ay pwedeng maipadala sa pamamagitan ng hindi maaasahan na mekanismo.  Sa case na ang cookie na ipinadala sa pakiusap,  nayayari ito kung ang HTTP, sa halip na HTTPS ay ginamit. Sa case ng ang cookie ay pinadala sa server na tugon (kung ang URL ay binago ang setting na nakapangalan sa parameter field na NULL), ang 'secure flag ay hindi naka-set, ito ay pumapayag sa cookie na maipadala mamaya sa HTTP sa halip na sa HTTPS. Ito ay maaring payagan ang passive eavesdropper sa network path para maka kuha ng buong access sa sesyon ng biktima.  
#Session Id Cookie not sent securely
ascanbeta.sessionidsentinsecurely.name = Sesyon ID na nai-transmit na hindi protektado
#these refs cannot be referenced, but we leave it here in the hope that it can be in the future..
ascanbeta.sessionidsentinsecurely.refs = https\://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication
ascanbeta.sessionidsentinsecurely.soln = 1) Gamitin ang pinakabagong magagamit na bersyon sa SSL/TLS (para sa HTTPS) para sa lahat ng mga pahina na ang sesyon id ay namamahagi sa pagitan ng browser at ng web server.\n2) Huwag payagan ang komunikasyon na pilitin na hindi ma encrypt ang HTTP protocol.\n3) Gamitin ang 'secure' na flag kung ikaw ay mag set sa cookie na naglalaman na session id, para maiwasan ang kasunod na mga transmisyon sa hindi secure na mekanismo.\n4) I-abante ang hindi secure na HTTP na pahina na mga kahilingan para ma-secure ang HTTPS na tugon ng pahina.  

ascanbeta.shellshock.desc = Ang server ay nagpapatakbo ng isang bersyon ng Bash shell na nagbibigay-daan sa mga malayong mga attaker na magsagawa ng arbitrary code 
ascanbeta.shellshock.extrainfo = Miula CVE-2014-6271\: GNU Bash sa pamamgitan ng 4.3 nagpoproseso ng mga trailing ng mga string matapos ang mga kahulugan ng mga values sa mga environment ng mga variables, na nagpapahintulot ng malayong mga attacker na nagsasagawa ng arbitrary code sa pamamagitan ng isang crafted na environment, tulad ng demonstrasyon sa vectors na kinasasangkutan ng ForceCommand feature sa OpenSSH sshd, ang mod_cgi na mga modyul sa Apche HTTP Server, ang mga script ay naka execute gamit ang hindi naka specify na mga DHCP clients, at ibang mga situation na setting ng environment na nagaganap sa kabila hanggang sa pribilehiyo mula sa Bash na execution, aka "ShellShock."Paunawa\: ang orihinal na ayusin para sa mga isyung hindi tama\: CVE-2014-7169 ay tinalaga upang masakop ang mga kahinaan ay pa rin sa kasalukuyan matapos ang maling pag-ayos.
ascanbeta.shellshock.name = Malayong Code pagpapatupad - Shell Shock
ascanbeta.shellshock.ref = https\://nvd.nist.gov/vuln/detail/CVE-2014-6271\nhttps\://www.troyhunt.com/everything-you-need-to-know-about2/
ascanbeta.shellshock.soln = I-update ang Bash sa server sa pinakabagong bersyon
ascanbeta.shellshock.timingbased.evidence = Gamitin ang ateke, isang abala sa [{0}] na milliseconds ay induced at na-detect

ascanbeta.sourcecodedisclosure.desc = The source code for the current page was disclosed by the web server.
ascanbeta.sourcecodedisclosure.gitbased.evidence = The source code for [{0}] was extracted using [{1}]
ascanbeta.sourcecodedisclosure.gitbased.name = Source Code Disclosure - Git 
ascanbeta.sourcecodedisclosure.gitbased.soln = Ensure that Git metadata files are not deployed to the web server or application server
ascanbeta.sourcecodedisclosure.lfibased.extrainfo = The output for the source code filename [{0}] differs sufficiently from that of the random parameter [{1}], at [{2}%], compared to a threshold of [{3}%]
ascanbeta.sourcecodedisclosure.lfibased.name = Source Code Disclosure - File Inclusion
ascanbeta.sourcecodedisclosure.svnbased.extrainfo = Ang source code ay para sa [{0}] ay matatagpuan sa [{1}]
ascanbeta.sourcecodedisclosure.svnbased.name = Source Code Disclosure - SVN
ascanbeta.sourcecodedisclosure.svnbased.soln = Tiyakin na ang SVN metadata na mga file ay hindi naipadala sa web server o application server

ascanbeta.sourcecodedisclosurecve-2012-1823.desc = Ibang mga PHP na mga bersyon, na kung na-configure ay ito ay pinagana gamit ang CGI, huwag nang hawakan ng maayos ang query na mga string na nakukulang ng unescaped "-" na karakter, na nagpapagana ng PHP source code disclosure, at ang arbitrary code excution. sa halimbawang ito, ang mga laman ng PHP file ay maglingod ng direkta sa web browser. Ang output ay karamihan naglalaman ng PHP, Bagamat ito ay naglalaman din ng straight HTML.
ascanbeta.sourcecodedisclosurecve-2012-1823.name = Source Code Disclosure - CVE-2012-1823
ascanbeta.sourcecodedisclosurecve-2012-1823.soln = Mag-upgrade sa pinakabagong matatag na bersyon ng PHP, o gamitin ang web server ng Apache at mod_rewrite module upang i-filter ang mga nakakahamak na kahilingan gamit ang direktiba ng "RewriteCond" at "RewriteRule".

ascanbeta.ssrf.desc = The web server receives a remote address and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.
ascanbeta.ssrf.name = Server Side Request Forgery
ascanbeta.ssrf.otherinfo.canaryinbody = The canary token from the out-of-band service was found in the response body.
ascanbeta.ssrf.refs = https\://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html
ascanbeta.ssrf.skipped = no Active Scan OAST service is selected.
ascanbeta.ssrf.soln = Do not accept remote addresses as request parameters, and if you must, ensure that they are validated against an allow-list of expected values.

ascanbeta.text4shell.desc = Apache Commons Text prior to 1.10.0 allows RCE when applied to untrusted input due to insecure interpolation defaults.Apache Commons Text performs variable interpolation, allowing properties to be dynamically evaluated and expanded.The application has been shown to initial contact with remote servers via variable interpolation and may well be vulnerable to Remote Code Execution (RCE).
ascanbeta.text4shell.name = Text4shell (CVE-2022-42889)
ascanbeta.text4shell.refs = https\://nvd.nist.gov/vuln/detail/CVE-2022-42889\nhttps\://securitylab.github.com/advisories/GHSL-2022-018_Apache_Commons_Text/
ascanbeta.text4shell.skipped = no Active Scan OAST service is selected.
ascanbeta.text4shell.soln = Upgrade Apache Commons Text prior to version 1.10.0 or newer.

ascanbeta.usernameenumeration.alert.attack = Manipulahin ang [{0}] field\: [{1}] at subaybayan ang output 
ascanbeta.usernameenumeration.alert.extrainfo = [{0}] parameter [{1}] ang may-kinalaman sa impormasyon sa kung umiiral ang isang user na umiiral. Ang [{5}] pagkakaiba ng output, para sa mga balidong orihinal na username na halaga [{2}], at imbalidong username na halaga [{3}] ay mga
ascanbeta.usernameenumeration.desc = Ito ay maaring posibleng isa-isahin ang mga username, batay sa magkakaibang HTTP na mga sagot kapag naglaan ng balido o imbalidong mga username. Ito ay lubhang madagdagan ang posibilidad ng tagumpay ng password ng pagpwersa ng taong ganid na pag-aatake laban sa system. Tandaan na ang maling positibo maaring kung minsan ay mababawasan ng pagtaas sa 'Atake ng lakas' na Opsyon sa ZAP. Mangayaring suriin nang manu-mano ang 'Other info' field upang kumpirmahin kung ito ay talagang isang isyu. 
ascanbeta.usernameenumeration.name = Posibleng Username na pagbibilang
ascanbeta.usernameenumeration.refs = https\://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/03-Identity_Management_Testing/04-Testing_for_Account_Enumeration_and_Guessable_User_Account.html\nhttps\://dl.ifip.org/db/conf/sec/sec2011/FreilingS11.pdf\nhttps\://cwe.mitre.org/data/definitions/204.html
ascanbeta.usernameenumeration.soln = Huwag ibubunyag ang mga detalye ng kung isang username ay balido o hindi balido. Higit sa lahat, para sa mga bigong pag-login pagtatangka, hindi ikumpara ang invalid user at isang imbalidong password sa mensahe ng error, pamagat ng pahina, nilalaman ng mga pahina, HTTP ulunanm o redirection na lohika.

