<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
Regras de varredura Passiva - Alfa
</title>
</head>
<body bgcolor="#ffffff">
<h1>Regras de verificação passiva - alfa</h1>
As seguintes regras de verificação passiva de qualidade alfa estão incluídas neste complemento:

<h2>Exposição do ViewState do ASP.NET</h2>
Um ViewState do ASP.NET foi exibido pelo servidor web/aplicativo

<h2>Integridade do ViewState do ASP.NET</h2>
O aplicativo não usa um código de autenticação de mensagem (MAC) para proteger a integridade do ASP.NET ViewState, que pode ser violado por um cliente malicioso

<h2>Exposição de Base64</h2>
Dados codificados em Base64 foram exibidos pelo servidor web/aplicativo

<h2>Falta o cabeçalho/header da política de segurança de conteúdo</h2>
Isto verifica os cabeçalhos de resposta para verificar a presença de um cabeçalho de política de segurança de conteúdo.<br>
Por padrão esta regra verifica a presença do cabeçalho "Content-Security-Policy" e em limiar Low também verifica se os cabeçalhos têm headers "X-WebKit-CSP" e "X-Content-Security-Policy".

<h2>Cookie Poisoning</h2>
Esta verificação confere a entrada fornecida pelo usuário nos parâmetros da string de query e nos dados de POST para identificar onde os parâmetros de cookie podem ser controlados. Isso é chamado ataque de cookie poisonining ou envenenamento de cookie e se torna explorável quando um atacante pode manipular o cookie de várias maneiras. Em alguns casos isso não vai ser explorável, mas permitir que parâmetros de URL definam valores de cookie é geralmente considerado um bug.

<h2>Configuração incorreta de domínio cruzado</h2>
Busca passivamente respostas contendo configurações incorretas de Domínio Cruzado, que relaxam a política de "mesma origem" no navegador da web, por exemplo.<br>
A implementação atual verifica cabeçalhos CORS excessivamente permissivos.

<h2>Pesquisa no diretório</h2>
Busca passivamente assinaturas de respostas indicando de que a navegação em diretório é possível.

<h2>Varredura passiva de arquivo-exemplo</h2>
Este recurso implementa uma regra de varredura passiva que carrega strings de um arquivo que o usuário pode editar.<br>
Para mais detalhes veja: http://zaproxy.blogspot.co.uk/2014/04/hacking-zap-3-passive-scan-rules.html

<h2>Exemplo de varredura passiva simples</h2>
Aqui implementamos um exemplo muito simples de regra de varredura passiva.<br>
Para mais detalhes veja: http://zaproxy.blogspot.co.uk/2014/04/hacking-zap-3-passive-scan-rules.html

<h2>Exposição de hash</h2>
Busca passivamente hashes de senhas exibidos pelo servidor web. <br>
Estão incluídos vários formatos, inclusive alguns como MD4, MD5 e SHA *, às vezes usados para outros fins além de conter hashes de senhas. 

<h2>HeartBleed</h2>
Varre passivamente à procura de respostas de cabeçalho HTTP indicando que o servidor está vulnerável à vulnerabilidade crítica  HeartBleed OpenSSL. 

<h2>Transição insegura de HTTP para HTTPS em post de formulário</h2>
Esta verificação procura páginas inseguras em HTTP que hospedam formulários HTTPS. A questão é que uma página HTTP insegura pode facilmente ser sequestrada por MITM-man-in-the-middle e o formulário seguro em HTTPS pode ser substituído ou falsificado.

<h2>Transição insegura de HTTP para HTTPS em post de formulário</h2>
Esta verificação procura páginas seguras em HTTPS que hospedam formulários inseguros HTTP. A questão é que uma página segura está em transição para uma página insegura enquanto dados são enviados através de um formulário. O usuário pode pensar que está enviando dados para uma página segura, quando na verdade não está.

<h2>Componente Inseguro</h2>
Esta checagem passivamente verifica os cabeçalhos de resposta do servidor e conteúdo do corpo gerador procurando versões de produtos, que são então comparados com uma lista de versões do produto conhecido por ser vulnerável a vários CVEs. 
Uma lista de escores de gravidade de CVEs e CVSS é a saída para cada produto registrado como vulnerável. 
Pelo lado do servidor, são registrados atualmente os seguintes produtos:<br>
Apache Tomcat application server (funcionalidade limitada devido à limitação do vazamento de informações pelo Tomcat)<br>
Apache web server<br>
mod_auth_radius Apache module<br>
mod_fcgid Apache module<br>
mod_imap Apache module<br>
mod_jk Apache module<br>
mod_perl Apache module<br>
mod_python Apache module<br>
mod_ssl Apache module<br>
OpenSSL Apache module<br>
Perl Apache module<br>
Python Apache module<br>
IBM HTTP Server<br>
JBoss application server<br>
Jetty web server / application server<br>
LiteSpeed web server<br>
Lighttpd web server<br>
Microsoft IIS web server<br>
Netscape Enterprise web server<br>
Nginx web server<br>
OpenCMS<br>
Oracle Application Server<br>
Oracle Web Cache<br>
PHP<br>
Phusion_Passenger<br>
Squid proxy server<br>
Sun One web server<br>
Sun Java System Web Server<br>
TornadoServer web server<br>
WordPress<br>

<h2>Scanner de localização de imagem</h2>
<p>Busca passivamente localização de GPS em imagens durante as avaliações de segurança normais de sites.  O scanner de localização de imagens auxilia em situações onde os usuários finais podem postar imagens de perfis e possivelmente dar sua localização em casa, por exemplo, um site de namoro ou sala de chat de crianças.  Um whitepaper sobre isso pode ser encontrado em http://veggiespam.com/ils/</p>

<p>Nota: Para este plug-in operar, o ZAP deve ser configurado para receber e processar imagens.  Para fazer isso, vá para o painel de opções ZAP (ferramentas &rarr; opções), escolha Exibir e habilitar a caixa de verificação "Processar imagens em solicitações/respostas HTTP".  Além disso, as imagens não podem ser filtradas através das configurações "Exclusão Global de URL" ou propriedades de sessão para "Excluir do Proxy". </p>

<h2>Open Redirect</h2>
Redirecionamentos abertos são uma das Top Ten vulnerabilidades 2010 da OWASP. Esta verificação busca a entrada fornecida pelo usuário nos parâmetros da string de query e nos dados de POST para identificar onde redirecionamentos diretos são possíveis. Redirecionamentos abertos ocorrem quando um aplicativo permite entrada fornecida pelo usuário (por exemplo, http://nottrusted.com) para controlar um redirecionamento externo. Este é geralmente uma maneira muito precisa de encontrar onde os redirecionamentos 301 ou 302 podem ser explorados por remetentes de spam ou ataques de phishing

<h2>Vazamento de informações de versão do servidor no cabeçalho/header</h2>
Esta verificação checa os cabeçalhos de resposta para a presença de um cabeçalho de servidor que contém detalhes de versão.

<h2>Exposição de código fonte</h2>
Código fonte da aplicação exposto pelo servidor web

<h2> Scanner de Strict Transport Security Header</h2>
Esta varredura verifica os cabeçalhos de resposta HTTPS para a presença de um cabeçalho HTTP Strict Transport Security (alerta se não for encontrado).
Também verifica se o cabeçalho HTTP Strict Transport Security (HST) contém uma diretiva de max-age com valor 0, que instrui os clientes para redefinirem toda a política HSTS associada com o Host do HSTS.

<h2>Exposição de timestamp</h2>
Um timestamp foi exposto pelo servidor web/aplicativo

<h2>Atributo de elemento HTML controlável pelo usuário (potencial XSS)</h2>
Esta verificação busca a entrada fornecida pelo usuário nos parâmetros da string de query e nos dados de POST para identificar onde certos valores de atributos de HTML podem ser controlados.  Isto proporciona detecção de hot-spot para XSS (cross-site scripting) que exigirá mais revisões por um analista de segurança para determinar a vulnerabilidade

<h2>Conjunto de caracteres (charset) controlável pelo usuário</h2>
Esta verificação confere a entrada fornecida pelo usuário nos parâmetros da string de query e nos dados de POST para identificar onde declarações de Content-Type ou de meta tag de conjunto de caracteres podem ser controlados pelo usuário. Tais declarações de charset sempre devem ser declaradas pelo aplicativo. Se um invasor pode controlar o conjunto de caracteres de resposta, eles pode manipular o HTML para executar XSS ou outros ataques.

<h2>Evento de javascript controlável pelo usuário (XSS)</h2>
Esta verificação busca a entrada fornecida pelo usuário nos parâmetros da string de query e nos dados de POST para identificar onde certos valores de atributos de HTML podem ser controlados.  Isto proporciona detecção de hot-spot para XSS (cross-site scripting) que exigirá mais revisões por um analista de segurança para determinar a vulnerabilidade            

<h2>Propriedade de javascript controlável pelo usuário (XSS)</h2>
Esta verificação busca a entrada fornecida pelo usuário nos parâmetros da string de query e nos dados de POST para identificar onde a URL em certas propriedades de javascript (ex: createElement scr) podem ser controladas. Isto proporciona detecção de hot-spot para XSS (cross-site scripting) que exigirá mais revisões por um analista de segurança para determinar a vulnerabilidade            

<h2>Vazamento de informações de cabeçalho X-Powered-By</h2>
Isto verifica os cabeçalhos de resposta para a presença de detalhes tipo X-Powered-By.

<h2>Vazamento de informações de cabeçalho X-Backend-server</h2>
Isto verifica os cabeçalhos de resposta para a presença de detalhes de X-backend-server.

<h2>Grande Redirecionamento</h2>
Esta verificação prevê o tamanho de várias respostas de tipo de redirecionamento e gera um alerta se a resposta for maior que o tamanho previsto. 
Uma resposta de redirecionamento grande pode indicar que embora um redirecionamento esteja acontecendo a página realmente tinha conteúdo (que pode revelar informações confidenciais, PII, etc).

<h2>Vazamento de informações de cabeçalho X-ChromeLogger-Data</h2>
Isto verifica nos cabeçalhos de resposta a presença de detalhes X-ChromeLogger-Data ou X-ChromePhp-Data.

</body>
</html>
